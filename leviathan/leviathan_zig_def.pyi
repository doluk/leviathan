from typing import TypeVar, TypeVarTuple, Callable, Self, Optional, Unpack, Coroutine, Any, TextIO
from types import FrameType
from contextvars import Context
import asyncio

_T = TypeVar('_T')


class Future(asyncio.Future[_T]):
    def __init__(self, loop: asyncio.AbstractEventLoop) -> None: ...
    def result(self) -> _T: ...
    def set_result(self, value: _T) -> None: ...
    def exception(self) -> Optional[BaseException]: ...
    def set_exception(self, exception: type|BaseException) -> None: ...
    def done(self) -> bool: ...
    def cancel(self, msg: Optional[str] = None) -> bool: ...
    def cancelled(self) -> bool: ...
    def add_callback(self, callback: Callable[[Self], None]) -> None: ...
    def remove_callback(self, callback: Callable[[Self], None]) -> int: ...
    def get_loop(self) -> asyncio.AbstractEventLoop: ...


class Task(asyncio.Task[_T]):
    def __init__(self, coro: Coroutine[Any, Any, _T], loop: asyncio.AbstractEventLoop, *, name: Optional[str] = None,
                 context: Optional[Context] = None) -> None: ...

    def uncancel(self) -> int: ...
    def cancelling(self) -> bool: ...
    def get_coro(self) -> Coroutine[Any, Any, _T]: ...
    def get_context(self) -> Context: ...
    def get_name(self) -> str: ...
    def set_name(self, name: Any) -> None: ...
    def get_stack(self, *, limit: Optional[int] = None) -> list[FrameType]: ...
    def print_stack(self, *, limit: Optional[int] = None, file: Optional[TextIO] = None) -> None: ...


_Tcs = TypeVarTuple("_Tcs")


class Loop(asyncio.AbstractEventLoop):
    def __init__(self, ready_tasks_queue_min_bytes_capacity: int,
              exception_handler: Callable[[Exception], None]) -> None: ...

    def run_forever(self) -> None: ...
    def stop(self) -> None: ...
    def is_running(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def close(self) -> None: ...

    def create_task(self, coro: Coroutine[Any, Any, _T], *, name: str | None = ..., context: Context | None = ...) -> Task[_T]: ...
    def create_future(self) -> Future[Any]: ...
    def time(self) -> float: ...

    def call_soon(self, callback: Callable[[Unpack[_Tcs]], object],
               *args: Unpack[_Tcs], context: Context | None = ...) -> asyncio.Handle: ...
    def call_soon_threadsafe(self, callback: Callable[[Unpack[_Tcs]], object], *args: Unpack[_Tcs], context: Context | None = ...) -> asyncio.Handle: ...
    def call_at(self, when: float, callback: Callable[[Unpack[_Tcs]], object], *args: Unpack[_Tcs], context: Context | None = ...) -> asyncio.TimerHandle: ...
    def call_later(self, delay: float, callback: Callable[[Unpack[_Tcs]], object], *args: Unpack[_Tcs], context: Context | None = ...) -> asyncio.TimerHandle: ...
